countries <- c("Germany", "France", "Netherlands", "Belgium")
countries
c(countries, "Poland")
mode(countries)
x > 15
x == sqrt(225)
babynames1 <- mutate(babynames, name_short = substr(name, 1, 3))
babynames1$ste <- babynames1$name_short == "Ste"
View(babynames1)
sum(y)
y <- c(1,10,NA,7,NA,11)
sum(y)
?sum
sum(y, na.rm = TRUE)
seq(1, 10, 2)
?seq
x
seq_along(x)
seq(1, length(x), 1)
?rep
rep(c(1, 2, 3), 3)
rep(c(1, 2, 3), each = 2)
vec1 <- c(2, 20, -5, 1, 200)
sort(vec1)
?sort
order(vec1, decreasing = FALSE)
dat <- data.frame(x, c(countries, "poland"))
dat <- data.frame(x, c(countries, "Poland", "Austria"))
dat
dat <- data.frame(var1 = x, var2 = c(countries, "Poland", "Austria"))
dat
arrange(dat, var1)
dat <- data.frame(var1 = vec1, var2 = c(countries, "Poland"))
dat
arrange(dat)
arrange(dat, var1)
dat[order(var1),]
dat[order(dat$var1),]
vec2 <- seq(1, 5)
vec1[order(vec1)]
vec4 <- vec3[!is.na(vec3)]
vec4
vec3 <- c(1,10,NA,7,NA,11)
vec4 <- vec3[!is.na(vec3)]
vec4
vec3[vec3 != NA]
z <- c(1,2,"Bavaria", 4)
z
z
str(z)
View(flights)
?read_csv
# variables
zz <- c(1,2,Bavaria,4,5,6) # error
Bavaria <- 3
zz <- c(1,2,Bavaria,4,5,6)
zz
str(zz)
zz
zzchar <- as.character(zz)
zzchar
zznum <- as.numeric(zzchar)
countries[2]
xzz[1:6] # xzz[seq(1,6)], xzz[c(1,2,3,4,5,6)]
xzz <- c(x,zz)
xzz[1:6] # xzz[seq(1,6)], xzz[c(1,2,3,4,5,6)]
xzz[c(2, 5, 10)]
xzz[-1]
zzchar
xzz
y
y[is.na(y)]
y[!is.na(y)]
y[y>5 | is.na(y)]
xzz
xzz[c(1, 3, 5)] <- c(100,110,120)
xzz_new <- xzz
xzz_new
xzz_new[xzz <= 100] <- 0
xzz_new[xzz > 100] <- 1
xzz_new
list1 <- list(vec1, vec2, babynames[1:5,])
list1
list1[[1]]
list1[[3]][,2]
names(list1)
names(list1) <- c("Vector1", "Vector2", "Data.Frame1")
names(list1)
list1
list1$Vector1[1]
song <- character()
song
for(i in 1:length(LETTERS)) {
song[i] <- paste0("Verse ", i, ": If you're happy and you know it, shout out ", LETTERS[i], "!")
}
song
LETTERS
letters
(a <- matrix(1:20, nrow = 5))
apply(a, 1, mean)
apply(a, 2, mean)
head(mtcars)
?mtcars
select(mtcars, gear, carb) %>% apply(1, mean)
lapply(mtcars, is.numeric)
sapply(mtcars, is.numeric)
lapply(mtcars, is.numeric) %>% unlist
my_mean <- function(my_vector) {
mean <- sum(my_vector)/length(my_vector)
mean
}
my_mean
my_mean()
my_mean(c(1, 2, 3))
my_mean <- function(my_vector = c(1, 2, 3, 4)) {
mean <- sum(my_vector)/length(my_vector)
mean
}
my_mean()
# function that returns the mean of a vector
my_mean <- function(my_vector) {
mean <- sum(my_vector)/length(my_vector)
mean
}
my_mean(c(1, 2, 3))
my_mean
my_mean(babynames)
my_mean(mtcars)
# another function that finds the remainder after division ("modulo operation)"
remainder <- function(num = 10, divisor = 4) {
remain <- num %% divisor
remain
}
remainder()
remainder(11, 3)
names(mtcars)
a
names(a)
has_name <- function(x) {
nms <- names(x)
if (is.null(nms)) {
rep(FALSE, length(x))
} else {
!is.na(nms) & nms != ""
}
}
has_name(c(1, 2, 3))
has_name(mtcars)
sapply(mtcars, function(x) length(unique(x)))
# generate a sample dataset
set.seed(1014)
df <- data.frame(replicate(6, sample(c(1:5, -99), 6, rep = TRUE)))
names(df) <- letters[1:6]
df
# build function
missing_fixer <- function(x, na.value) {
x[x == na.value] <- NA
x
}
df[] <- lapply(df, missing_fixer, na.value = -99) # littler trick to make sure we get back a data frame, not a list
df
library(haven)
?read_dta
?recode
## load packages
library(rvest)
library(stringr)
library(quanteda)
# step 1: parse page
url <- "http://www.nytimes.com"
html_parsed <- read_html(url, encoding = "UTF-8")
# step 2: construct and apply XPath expression using SelectorGadget (in browser)
xpath <- '//*[contains(concat( " ", @class, " " ), concat( " ", "story-heading", " " ))]'
headings <- html_nodes(html_parsed, xpath = xpath) %>% html_text()
headings
# step 3: clean data
headings <- str_replace_all(headings, "\\n" , " ") %>% str_trim()
headings
# step 4: plot data in word cloud
headings_dfm <- dfm(headings, remove = stopwords(), remove_punct = TRUE)
textplot_wordcloud(headings_dfm)
# install current version of Java SE Runtime Environment
browseURL("http://www.oracle.com/technetwork/java/javase/downloads/jre8-downloads-2133155.html")
# check currently installed version of Java
system("java -version")
# load RSelenium
library(RSelenium)
# initiate Selenium driver
rD <- rsDriver()
# load RSelenium
library(RSelenium)
# check currently installed version of Java
system("java -version")
# load RSelenium
library(RSelenium)
# check currently installed version of Java
system("java -version")
# initiate Selenium driver
rD <- rsDriver()
# initiate Selenium driver
rD <- rsDriver()
remDr <- rD[["client"]]
# start browser, navigate to page
url <- "https://www.imdb.com/search/title"
remDr$navigate(url)
# enter keyword in title field
xpath <- '//*[@id="main"]/div[1]/div[2]/input'
titleElem <- remDr$findElement(using = 'xpath', value = xpath)
enterTitle <- titleElem$sendKeysToElement(list("data")) # enter key word
remDr <- rD[["client"]]
# start browser, navigate to page
url <- "https://www.imdb.com/search/title"
remDr$navigate(url)
# close connection
remDr$closeServer()
# initiate Selenium driver
rD <- rsDriver()
remDr <- rD[["client"]]
# initiate Selenium driver
rD <- rsDriver()
remDr$navigate(url)
# start browser, navigate to page
url <- "https://www.imdb.com/search/title"
remDr$navigate(url)
# initiate Selenium driver
rD <- rsDriver()
# start browser, navigate to page
url <- "https://www.imdb.com/search/title"
remDr$navigate(url)
# load RSelenium
library(RSelenium)
# check currently installed version of Java
system("java -version")
# initiate Selenium driver
rD <- rsDriver()
remDr <- rD[["client"]]
# start browser, navigate to page
url <- "https://www.imdb.com/search/title"
remDr$navigate(url)
# enter keyword in title field
xpath <- '//*[@id="main"]/div[1]/div[2]/input'
titleElem <- remDr$findElement(using = 'xpath', value = xpath)
enterTitle <- titleElem$sendKeysToElement(list("data")) # enter key word
# select requested title data
xpath <- '//*[@id="main"]/div[8]/div[2]/select/option[10]'
titledatElem <- remDr$findElement(using = 'xpath', value = xpath)
select <- titledatElem$clickElement() # click on button
# select requested title data
xpath <- '//*[@id="main"]/div[8]/div[2]/select/option[7]'
titledatElem1 <- remDr$findElement(using = 'xpath', value = xpath)
select <- titledatElem1$clickElement() # click on button
titledatElem1$clickElement()
titledatElem2$clickElement()
xpath <- '//*[@id="main"]/div[8]/div[2]/select/option[10]' # technical info
titledatElem2 <- remDr$findElement(using = 'xpath', value = xpath)
titledatElem2$clickElement()
titledatElem1$clickElement() # click on list element
titledatElem2$clickElement() # click on list element
webElem <- remDr$findElement("css", "body")
webElem$sendKeysToElement(list(key = "down_arrow"))
webElem$sendKeysToElement(list(key = "up_arrow"))
webElem$sendKeysToElement(list(key = "up_arrow"))
webElem$sendKeysToElement(list(key = "up_arrow"))
webElem$sendKeysToElement(list(key = "end"))
# click on search button
xpath <- '//*[@id="main"]/p[3]/button'
searchElem <- remDr$findElement(using = 'xpath', value = xpath)
searchElem$clickElement() # click on button
# store index page
output <- remDr$getPageSource(header = TRUE)
write(output[[1]], file = "data/imdb-data-movies.html")
# parse html
content <- read_html("data/imdb-data-movies.html")
library(rvest)
# parse html
content <- read_html("data/imdb-data-movies.html")
titles <- html_nodes(content, '//*[contains(concat( " ", @class, " " ), concat( " ", "lister-item-header", " " ))]//a') %>% html_text
titles <- html_nodes(content, xpath = '//*[contains(concat( " ", @class, " " ), concat( " ", "lister-item-header", " " ))]//a') %>% html_text
titles
head(titles)
## load packages
library(rvest)
library(stringr)
library(quanteda)
# step 1: parse page
url <- "http://www.nytimes.com"
html_parsed <- read_html(url, encoding = "UTF-8")
# step 2: construct and apply XPath expression using SelectorGadget (in browser)
xpath <- '//*[contains(concat( " ", @class, " " ), concat( " ", "story-heading", " " ))]'
headings <- html_nodes(html_parsed, xpath = xpath) %>% html_text()
headings
# step 3: clean data
headings <- str_replace_all(headings, "\\n" , " ") %>% str_trim()
headings
# step 4: plot data in word cloud
headings_dfm <- dfm(headings, remove = stopwords(), remove_punct = TRUE)
textplot_wordcloud(headings_dfm)
warnings()
textplot_wordcloud(headings_dfm)
## load packages
library(rvest)
library(stringr)
library(quanteda)
# step 1: parse page
url <- "http://www.nytimes.com"
## load packages
library(rvest)
library(stringr)
library(quanteda)
# step 1: parse page
url <- "http://www.nytimes.com"
html_parsed <- read_html(url, encoding = "UTF-8")
# step 2: construct and apply XPath expression using SelectorGadget (in browser)
xpath <- '//*[contains(concat( " ", @class, " " ), concat( " ", "story-heading", " " ))]//a'
headings <- html_nodes(html_parsed, xpath = xpath) %>% html_text()
headings
# step 1: parse page
url <- "http://www.nytimes.com"
html_parsed <- read_html(url, encoding = "UTF-8")
# step 2: construct and apply XPath expression using SelectorGadget (in browser)
xpath <- '//*[contains(concat( " ", @class, " " ), concat( " ", "story-heading", " " ))]//a'
headings <- html_nodes(html_parsed, xpath = xpath) %>% html_text()
headings
## load packages
library(rvest)
library(stringr)
library(quanteda)
# step 1: parse page
url <- "http://www.nytimes.com"
html_parsed <- read_html(url, encoding = "UTF-8")
# step 2: construct and apply XPath expression using SelectorGadget (in browser)
xpath <- '//*[contains(concat( " ", @class, " " ), concat( " ", "story-heading", " " ))]//a'
headings <- html_nodes(html_parsed, xpath = xpath) %>% html_text()
headings
# step 3: clean data
headings <- str_replace_all(headings, "\\n" , " ") %>% str_trim()
headings
# step 4: plot data in word cloud
headings_dfm <- dfm(headings, remove = stopwords(), remove_punct = TRUE)
textplot_wordcloud(headings_dfm)
# install current version of Java SE Development Kit
browseURL("http://www.oracle.com/technetwork/java/javase/downloads/jdk9-downloads-3848520.html")
# load RSelenium
library(RSelenium)
library(rvest)
# check currently installed version of Java
system("java -version")
# initiate Selenium driver
rD <- rsDriver()
remDr <- rD[["client"]]
# start browser, navigate to page
url <- "https://www.imdb.com/search/title"
remDr$navigate(url)
# start browser, navigate to page
url <- "https://www.imdb.com/search/title"
remDr$navigate(url)
# enter keyword in title field
xpath <- '//*[@id="main"]/div[1]/div[2]/input'
titleElem <- remDr$findElement(using = 'xpath', value = xpath)
titleElem$sendKeysToElement(list("data")) # enter key word
# select requested title data
xpath <- '//*[@id="main"]/div[8]/div[2]/select/option[7]' # plot
titledatElem1 <- remDr$findElement(using = 'xpath', value = xpath)
titledatElem1$clickElement() # click on list element
titledatElem1$clickElement() # click on list element
xpath <- '//*[@id="main"]/div[8]/div[2]/select/option[10]' # technical info
titledatElem2 <- remDr$findElement(using = 'xpath', value = xpath)
titledatElem2$clickElement() # click on list element
# scroll to end of page (just for fun)
webElem <- remDr$findElement("css", "body")
webElem$sendKeysToElement(list(key = "end"))
# click on search button
xpath <- '//*[@id="main"]/p[3]/button'
searchElem <- remDr$findElement(using = 'xpath', value = xpath)
searchElem$clickElement() # click on button
# store index page
output <- remDr$getPageSource(header = TRUE)
write(output[[1]], file = "data/imdb-data-movies.html")
# close connection
remDr$closeServer()
# parse html
content <- read_html("data/imdb-data-movies.html")
titles <- html_nodes(content, xpath = '//*[contains(concat( " ", @class, " " ), concat( " ", "lister-item-header", " " ))]//a') %>% html_text
head(titles)
# install current version of Java SE Development Kit
browseURL("http://www.oracle.com/technetwork/java/javase/downloads/jdk9-downloads-3848520.html")
# install current version of Java SE Development Kit
browseURL("http://www.oracle.com/technetwork/java/javase/downloads/jdk9-downloads-3848520.html")
# install current version of Java SE Development Kit
browseURL("http://www.oracle.com/technetwork/java/javase/downloads/jdk9-downloads-3848520.html")
# install current version of Java SE Development Kit
browseURL("http://www.oracle.com/technetwork/java/javase/downloads/jdk9-downloads-3848520.html")
# install current version of Java SE Development Kit
browseURL("http://www.oracle.com/technetwork/java/javase/downloads/jdk9-downloads-3848520.html")
# load RSelenium
library(RSelenium)
library(rvest)
# check currently installed version of Java
system("java -version")
# initiate Selenium driver
rD <- rsDriver()
remDr <- rD[["client"]]
# start browser, navigate to page
url <- "https://www.imdb.com/search/title"
remDr$navigate(url)
# enter keyword in title field
xpath <- '//*[@id="main"]/div[1]/div[2]/input'
titleElem <- remDr$findElement(using = 'xpath', value = xpath)
titleElem$sendKeysToElement(list("data")) # enter key word
# select requested title data
xpath <- '//*[@id="main"]/div[8]/div[2]/select/option[7]' # plot
titledatElem1 <- remDr$findElement(using = 'xpath', value = xpath)
titledatElem1$clickElement() # click on list element
titledatElem1$clickElement() # click on list element
titledatElem2 <- remDr$findElement(using = 'xpath', value = xpath)
xpath <- '//*[@id="main"]/div[8]/div[2]/select/option[10]' # technical info
titledatElem2 <- remDr$findElement(using = 'xpath', value = xpath)
titledatElem2$clickElement() # click on list element
# scroll to end of page (just for fun)
webElem <- remDr$findElement("css", "body")
webElem$sendKeysToElement(list(key = "end"))
# click on search button
xpath <- '//*[@id="main"]/p[3]/button'
searchElem <- remDr$findElement(using = 'xpath', value = xpath)
searchElem$clickElement() # click on button
# store index page
output <- remDr$getPageSource(header = TRUE)
write(output[[1]], file = "data/imdb-data-movies.html")
# close connection
remDr$closeServer()
# parse html
content <- read_html("data/imdb-data-movies.html")
titles <- html_nodes(content, xpath = '//*[contains(concat( " ", @class, " " ), concat( " ", "lister-item-header", " " ))]//a') %>% html_text
head(titles)
source("packages.r")
# to create strings, both single and double quotes work
string1 <- 'This is a string'
string2 <- 'If I want to include a "quote" inside a string, I use single quotes'
# to include a literal single or double quote in a string you can use \ to escape it:
double_quote <- "\"" # or '"'
single_quote <- '\'' # or "'"
double_quote
single_quote
# printed representation of a string shows the escapes
double_quote
writeLines(double_quote) # shows raw contents of the string
cat(double_quote)
?cat
# not very consistent when it comes to UTF-8 code points
x <- "\u00b5"
x
writeLines(x)
# inspect text
x <- c("apple", "banana", "pear")
str_view(x, "an")
str_view_all(x, "an")
str_view_all(x, "a")
# example
raw.data <- "555-1239Moe Szyslak(636) 555-0113Burns, C. Montgomery555-6542Rev. Timothy Lovejoy555 8904Ned Flanders636-555-3226Simpson, Homer5553642Dr. Julius Hibbert"
# running example
example.obj <- "1. A small sentence. - 2. Another tiny sentence."
# multiple matches
(out <- str_extract_all(c("text", "manipulation", "basics"), "a"))
# character class: range
str_extract(example.obj, "sm[a-p]ll")
# character class: additional characters
unlist(str_extract_all(example.obj, "[uvw. ]"))
# pre-defined character classes
unlist(str_extract_all(example.obj, "[:punct:]"))
unlist(str_extract_all(example.obj, "[[:punct:]ABC]"))
unlist(str_extract_all(example.obj, "[^[:alnum:]]"))
# for more character classes, see
?base::regex
# additional shortcuts
unlist(str_extract_all(example.obj, "\\w+"))
# word edges
unlist(str_extract_all(example.obj, "e\\b"))
unlist(str_extract_all(example.obj, "e\\B"))
# quantifier
str_extract(example.obj, "s[[:alpha:]][[:alpha:]][[:alpha:]]l")
# for more character classes, see
?base::regex
# additional shortcuts
unlist(str_extract_all(example.obj, "\\w+"))
# greedy quantification
str_extract(example.obj, "A.+sentence")
str_extract(example.obj, "A.+?sentence")
# quantifier with pattern sequence
unlist(str_extract_all(example.obj, "(.en){1,5}"))
unlist(str_extract_all(example.obj, ".en{1,5}"))
# grouped matches
str_extract_all(example.obj, "([^ ]+) (sentence)")
str_match_all(example.obj, "([^ ]+) (sentence)")
# assertions
unlist(str_extract_all(example.obj, "(?<=2. ).+")) # positive lookbehind: (?<=...)
unlist(str_extract_all(example.obj, ".+(?=2)")) # positive lookahead (?=...)
unlist(str_extract_all(example.obj, "(?<!Blah )tiny.+")) # negative lookbehind: (?<!...)
example.obj
unlist(str_extract_all(example.obj, "sentence.+(?!Bla)")) # negative lookahead (?!...)
# joining
str_c("text", "manipulation", sep = " ")
# manipulate multiple elements; example
(char.vec <- c("this", "and this", "and that"))
# padding and trimming
length.char.vec <- str_length(char.vec)
char.vec <- str_pad(char.vec, width = max(length.char.vec), side = "both", pad = " ")
char.vec
str_trim(char.vec)
# joining
str_c("text", "manipulation", sep = " ")
str_c(char.vec, collapse = "\n") %>% cat
str_c("text", c("manipulation", "basics"), sep = " ")
